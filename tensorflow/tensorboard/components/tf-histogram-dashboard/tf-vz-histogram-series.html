<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../bower_components/polymer/polymer.html">

<dom-module id="tf-vz-histogram-series">

  <template>
    <style>
      :host {
        display: block;
      }

      svg {
        font-family: roboto, sans-serif;
      }

      .background {
        fill-opacity: 0;
        fill: red;
      }

      .histogram {
        pointer-events: none;
      }

      .hover {
        font-size: 9px;
        dominant-baseline: middle;
        opacity: 0;
      }

      .hover circle {
        stroke: white;
        stroke-opacity: 0.5;
        stroke-width: 1px;
      }

      .baseline {
        stroke: black;
        stroke-opacity: 0.1;
        /*stroke-dasharray: 2;*/
        /*display: none;*/
      }

      .outline {
        fill: none;
        stroke: white;
        stroke-opacity: 0.5;
        /*stroke-alignment: outer;*/
        /*not implemented?*/
      }

      .x-axis-hover {
        pointer-events: none;
      }

      .x-axis-hover .label {
        opacity: 0;
        font-weight: bold;
        font-size: 11px;
        text-anchor: end;
      }

      .x-axis-hover g:nth-child(2) text {
        text-anchor: start;
      }

      .x-axis-hover line {
        stroke: black;
      }

      .x-axis-hover rect {
        fill: white;
      }

      .gradient {
      }

      .axis {
        font-size: 10px;
        fill: #aaa;
      }

      .axis .domain {
        fill: none;
      }

      .axis .tick line {
        stroke: #ddd;
      }

      .axis.slice {
        opacity: 0;
      }

      .axis.slice .tick line {
        stroke-dasharray: 2;
      }
    </style>
    <svg id="svg">
      <g>
        <g class="axis x"></g>
        <g class="axis y"></g>
        <g class="axis y slice"></g>
        <g class="stage">
          <rect class="background"></rect>
        </g>
        <g class="x-axis-hover"></g>
      </g>
    </svg>

  </template>

  <script>
  "use strict";
  Polymer({
    is: "tf-vz-histogram-series",
    properties: {
      mode: { type: String, value: "offset" }, //offset|overlay
      time: { type: String, value: "i" }, //step|wall|i
      width: { type: Number, value: 500 },
      height: { type: Number, value: 500 },
      data: { type: Object, value: [] }
    },
    draw: function(duration) {

      //
      // Initialization
      //

      var duration = (duration ? duration : 0);
      var data = this.data;
      var mode = this.mode;
      var time = this.time;
      var outerWidth = this.width,
          outerHeight = this.height;

      var sliceHeight,
          margin = { top: 5, right: 60, bottom: 20, left: 5};

      if (outerWidth < 250) {
        margin.right = 5;
        margin.bottom = 5;
      }
      if (mode === "offset") {
        sliceHeight = outerHeight / 2.5;
        margin.top = sliceHeight + 5;
      } else {
        sliceHeight = outerHeight - margin.top - margin.bottom;
      }


      var width = outerWidth - margin.left - margin.right,
          height = outerHeight - margin.top - margin.bottom;

      var leftMin = d3.min(data, function(d) { return d.leftMin; }),
          rightMax = d3.max(data, function(d) { return d.rightMax; });
      //
      // Formats
      //

      var formatTime = d3.time.format("%x"),
          format = d3.format(".3n");

      //
      // Scales and axis
      //

      let outlineCanvasSize = 500;

      var yScale = (time === "step" ? d3.scale.linear() : d3.time.scale())
          .domain(d3.extent(data, function(d) { return d[time]; }))
          .range([0, (mode === "offset" ? height : 0)]);

      var ySliceScale = d3.scale.linear()
          .domain([0, d3.max(data, function(d) { return d.areaMax; })])
          .range([sliceHeight, 0]);

      var yLineScale = d3.scale.linear()
          .domain(ySliceScale.domain())
          .range([outlineCanvasSize, 0]);

      var xScale = d3.scale.linear()
          .domain([
            d3.min(data, function(d) { return d.leftMin; }),
            d3.max(data, function(d) { return d.rightMax; })
          ])
          .range([0, width]);

      var xLineScale = d3.scale.linear()
          .domain([
            d3.min(data, function(d) { return d.leftMin; }),
            d3.max(data, function(d) { return d.rightMax; })
          ])
          .range([0, outlineCanvasSize]);

      var outlineColor = d3.scale.linear()
          .domain(d3.extent(data, function(d) { return d[time]; }))
          .range(["orange", "darkred"])
          .interpolate(d3.interpolateHcl);

      var xAxis = d3.svg.axis()
              .scale(xScale)
              .ticks(width > 100 ? 10 : 2)
              .orient("bottom"),
          yAxis = d3.svg.axis()
              .scale(yScale)
              // .tickFormat(formatTime)
              .ticks(width > 100 ? 10 : 2)
              .orient("right"),
          ySliceAxis = d3.svg.axis()
              .scale(ySliceScale)
              .ticks(width > 100 ? 10 : 2)
              .tickSize(width + 5)
              .orient("right");

      var path = d3.svg.area()
          .interpolate("linear")
          .x(function(d) { return xLineScale(d.center); })
          .y0(function(d) { return yLineScale(0); })
          .y1(function(d) { return yLineScale(d.area); });

      //
      // Render
      //

      var svgNode = this.$.svg;

      var svg = d3.select(svgNode);

      var svgTransition = svg.transition().duration(duration)
          .attr("width", outerWidth)
          .attr("height", outerHeight);

      var g = svg.select("g");

      var gTransition = svgTransition.select("g")
          .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      var bisect = d3.bisector(function(d) { return d.right; }).left;
      var stage = g.select(".stage")
          .on("mouseover", function() {
            hoverUpdate.transition().style("opacity", 1);
            edgeLabelUpdate.transition().style("opacity", 1)
          })
          .on("mouseout", function() {
            hoverUpdate.transition().style("opacity", 0);
            edgeLabelUpdate.transition().style("opacity", 0)
          })
          .on("mousemove", function() {
            var m = d3.mouse(this),
                v = xScale.invert(m[0]);

            function hoverXIndex(d) {
              return Math.min(d.histogramData.length - 1, bisect(d.histogramData, v));
            }

            var lastSliceData;
            hoverUpdate
              .attr("transform", function(d) {
                var index = hoverXIndex(d);
                lastSliceData = d;
                [].forEach.call(this.querySelectorAll("text"), function(n){
                  n.textContent = format(d.histogramData[index].count);
                });
                return "translate(" + xScale(d.histogramData[index].center) + "," + ySliceScale(d.histogramData[index].area) + ")";
              });

            var index = hoverXIndex(lastSliceData);

            edgeLabelUpdate
                .attr("transform", function(d) { return"translate(" + xScale(lastSliceData.histogramData[index][d]) + ", " + height + ")"; })
              .select("text")
                .text(function(d) { return format(lastSliceData.histogramData[index][d]); });
          });

      var background = stage.select(".background")
          .attr("transform", "translate(" + -margin.left + "," + -margin.top + ")")
          .attr("width", outerWidth)
          .attr("height", outerHeight);

      var histogram = stage.selectAll(".histogram").data(data, function(d) { return d.step; }),
          histogramExit = histogram.exit().remove(),
          histogramEnter = histogram.enter().append("g").attr("class", "histogram"),
          histogramUpdate = histogram
              .sort(function(a, b) { return a[time] - b[time]; }),
          histogramTransition = gTransition.selectAll(".histogram")
              .attr("transform", function(d) {
                return "translate(0, " + (mode === "offset" ? (yScale(d[time]) - sliceHeight) : 0) + ")";
              });

      var baselineEnter = histogramEnter.append("line").attr("class", "baseline"),
          baselineUpdate = histogramTransition.select(".baseline")
              .style("stroke-opacity", function(d) { return (mode === "offset" ? 0.1 : 0); })
              .attr("y1", sliceHeight)
              .attr("y2", sliceHeight)
              .attr("x2", width);

      var outlineEnter = histogramEnter.append("path").attr("class", "outline"),
          outlineUpdate = histogramUpdate.select(".outline")
              .attr("vector-effect", "non-scaling-stroke")
              .attr("d", function(d) { return path(d.histogramData); })
              .style("stroke-width", 1),
          outlineTransition = histogramTransition.select(".outline")
              .attr("transform", "scale(" + width / outlineCanvasSize + ", " + sliceHeight / outlineCanvasSize + ")")
              .style("stroke", function(d) { return (mode === "offset" ? "white" : outlineColor(d[time])); })
              .style("fill-opacity", function(d) { return (mode === "offset" ? 1 : 0); })
              .style("fill", function(d) { return outlineColor(d[time]); });


      var hoverEnter = histogramEnter.append("g")
              .attr("class", "hover")
              .style("fill", function(d) { return outlineColor(d[time]); }),
          hoverUpdate = histogramUpdate.select(".hover");

      hoverEnter.append("circle")
          .attr("r", 2);

      hoverEnter.append("text")
          .style("display", "none")
          .style("stroke", "white")
          .style("stroke-width", 2)
          .attr("dx", 4);

      hoverEnter.append("text")
          .style("display", "none")
          .attr("dx", 4);

      var edgeLabel = g.select(".x-axis-hover").selectAll(".label").data(["left", "right"]),
          edgeLabelEnter = edgeLabel.enter().append("g").attr("class", "label"),
          edgeLabelUpdate = edgeLabel;

      edgeLabelEnter.append("rect")
          .attr("x", function(d) { return (d === "left" ? -25 : 0);})
          .attr("y", 6)
          .attr("width", 25)
          .attr("height", 14)

      edgeLabelEnter.append("line")
          .attr("x1", 0)
          .attr("x2", 0)
          .attr("y1", 0)
          .attr("y2", 6);

      edgeLabelEnter.append("text")
          .attr("dx", function(d) { return (d === "left" ? -4 : 4);})
          .attr("dy", 18);

      gTransition.select(".y.axis.slice")
          .style("opacity", mode === "offset" ? 0 : 1)
          .attr("transform", "translate(0, " + (mode === "offset" ? -sliceHeight : 0) + ")")
          .call(ySliceAxis);

      gTransition.select(".x.axis")
          .attr("transform", "translate(0, " + height + ")")
          .call(xAxis);

      gTransition.select(".y.axis")
          .style("opacity", mode === "offset" ? 1 : 0)
          .attr("transform", "translate(" + width + ", " + (mode === "offset" ? 0 : height) + ")")
          .call(yAxis);

      // Polymer's way of scoping styles on nodes that d3 created
      // It naively adds classes to all child nodes
      // each time you call it. second param is mutation observer option,
      // but reluctant to add that, need to investigate more.
      this.scopeSubtree(this.$["svg"], false);

    }
  });
  </script>

</dom-module>
